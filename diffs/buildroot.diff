diff --git a/package/Config.in b/package/Config.in
index 4d323d440f..a5aac24bb7 100644
--- a/package/Config.in
+++ b/package/Config.in
@@ -2547,4 +2547,7 @@ menu "Text editors and viewers"
 	source "package/vim/Config.in"
 endmenu
 
+source "package/accel_driver/Config.in"
+source "package/accel_test/Config.in"
+
 endmenu
diff --git a/package/accel_driver/Config.in b/package/accel_driver/Config.in
new file mode 100644
index 0000000000..c928802819
--- /dev/null
+++ b/package/accel_driver/Config.in
@@ -0,0 +1,4 @@
+config BR2_PACKAGE_ACCEL_DRIVER
+    bool "Accelerator driver (simple kernel module)"
+    help
+      A simple accelerator driver for testing Buildroot kernel module integration.
\ No newline at end of file
diff --git a/package/accel_driver/accel_driver.mk b/package/accel_driver/accel_driver.mk
new file mode 100644
index 0000000000..c9fdcf679b
--- /dev/null
+++ b/package/accel_driver/accel_driver.mk
@@ -0,0 +1,14 @@
+################################################################################
+# accel_driver.mk
+################################################################################
+
+ACCEL_DRIVER_VERSION = 1.0
+ACCEL_DRIVER_SITE = /home/aviva/cheshire/sw/deps/cva6-sdk/driver
+ACCEL_DRIVER_SITE_METHOD = local
+
+ACCEL_DRIVER_MODULE_SUBDIRS = .
+ACCEL_DRIVER_LICENSE = GPL-2.0
+ACCEL_DRIVER_LICENSE_FILES = COPYING
+
+$(eval $(kernel-module))
+$(eval $(generic-package))
diff --git a/package/accel_test/Config.in b/package/accel_test/Config.in
new file mode 100644
index 0000000000..77530ca169
--- /dev/null
+++ b/package/accel_test/Config.in
@@ -0,0 +1,6 @@
+config BR2_PACKAGE_ACCEL_TEST
+    bool "accel_test"
+    default y
+    help
+      A simple accelerator test
+
diff --git a/package/accel_test/accel_test.mk b/package/accel_test/accel_test.mk
new file mode 100644
index 0000000000..d517de4a4b
--- /dev/null
+++ b/package/accel_test/accel_test.mk
@@ -0,0 +1,19 @@
+################################################################################
+# accel_test
+################################################################################
+
+ACCEL_TEST_VERSION = 1.0
+ACCEL_TEST_SITE = package/accel_test/src
+ACCEL_TEST_SITE_METHOD = local
+
+ACCEL_TEST_LICENSE = MIT
+
+define ACCEL_TEST_BUILD_CMDS
+	$(TARGET_MAKE_ENV) $(MAKE) CC="$(TARGET_CC)" CFLAGS="$(TARGET_CFLAGS)" LDFLAGS="$(TARGET_LDFLAGS)" -C $(@D)
+endef
+
+define ACCEL_TEST_INSTALL_TARGET_CMDS
+	$(INSTALL) -D -m 0755 $(@D)/accel_test $(TARGET_DIR)/usr/bin/accel_test
+endef
+
+$(eval $(generic-package))
\ No newline at end of file
diff --git a/package/accel_test/original-src/Makefile b/package/accel_test/original-src/Makefile
new file mode 100644
index 0000000000..270bdccaee
--- /dev/null
+++ b/package/accel_test/original-src/Makefile
@@ -0,0 +1,13 @@
+# Use buildroot's cross-compiler (RISC-V)
+CC ?= $(TARGET_CC)
+CFLAGS ?= $(TARGET_CFLAGS)
+LDFLAGS ?= $(TARGET_LDFLAGS)
+
+all:
+	$(CC) $(CFLAGS) $(LDFLAGS) -o accel_test accel.c accel_test.c 
+
+install:
+	install -D -m 0755 accel_test $(DESTDIR)/usr/bin/accel_test
+
+clean:
+	rm -f accel_test
diff --git a/package/accel_test/original-src/accel.c b/package/accel_test/original-src/accel.c
new file mode 100644
index 0000000000..c6c6e33a04
--- /dev/null
+++ b/package/accel_test/original-src/accel.c
@@ -0,0 +1,47 @@
+#include "accel.h"
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <string.h>
+#include <stdio.h>
+#include <errno.h>
+
+int accel_open(accel_t *accel, const char *device) {
+    if (!device) device = DEVICE;
+    accel->fd = open(device, O_RDWR);
+    return (accel->fd < 0) ? -errno : 0;
+}
+
+void accel_close(accel_t *accel) {
+    if (accel->fd >= 0) close(accel->fd);
+    accel->fd = -1;
+}
+
+int accel_read_vec0(accel_t *accel, uint32_t *data, uint32_t index) {
+    lseek(accel->fd, REG0_OFFSET + index * 4, SEEK_SET);  // reg0 offset = 0
+    return read(accel->fd, data, 4);    // reg0 offset = 0
+}
+
+int accel_read_vec1(accel_t *accel, uint32_t *data, uint32_t index) {
+    lseek(accel->fd, REG1_OFFSET + index * 4, SEEK_SET);  // reg1 offset = 0x80
+    return read(accel->fd, data, 4);    // reg1 offset = 0x80
+}
+
+int accel_write_vec0(accel_t *accel, uint32_t *data, uint32_t index) {
+    lseek(accel->fd, REG0_OFFSET + index * 4, SEEK_SET);  // reg0 offset = 0
+    return write(accel->fd, data, 4);   // reg0 offset = 0
+}
+
+int accel_write_vec1(accel_t *accel, uint32_t *data, uint32_t index) {
+    lseek(accel->fd, REG1_OFFSET + index * 4, SEEK_SET);  // reg1 offset = 0x80
+    return write(accel->fd, data, 4);   // reg1 offset = 0x80
+}
+
+int accel_trigger(accel_t *accel, uint32_t opcode) {
+    return ioctl(accel->fd, ACCEL_IOC_OPCODE, &opcode);
+}
+
+int accel_read_result(accel_t *accel, uint64_t* data, uint32_t index) {
+    lseek(accel->fd, REG_RESULT_OFFSET + index * 8, SEEK_SET);
+    return read(accel->fd, data, 8);
+}
diff --git a/package/accel_test/original-src/accel.h b/package/accel_test/original-src/accel.h
new file mode 100644
index 0000000000..26e9d4ac2a
--- /dev/null
+++ b/package/accel_test/original-src/accel.h
@@ -0,0 +1,52 @@
+#ifndef ACCEL_H
+#define ACCEL_H
+
+#include <stdint.h>
+#include <sys/types.h>
+
+#define DEVICE "/dev/accel"
+#define ACCEL_IOC_MAGIC 'x'
+#define ACCEL_IOC_OPCODE _IOW(ACCEL_IOC_MAGIC, 1, uint32_t)
+#define REG0_OFFSET       0x00
+#define REG1_OFFSET       0x80
+#define REG_RESULT_OFFSET 0x100
+#define OPCODE_OFFSET     0x180
+
+typedef struct {
+    int fd;
+} accel_t;
+
+enum accel_opcodes {
+    ACCEL_OP_ADD = 1,
+    ACCEL_OP_SUB = 2,
+    ACCEL_OP_AND = 3,
+    ACCEL_OP_OR = 4,
+    ACCEL_OP_XOR = 5,
+    ACCEL_OP_MUL = 6
+};
+
+// Initialize the accelerator
+int accel_open(accel_t *accel, const char *device);
+
+// Close accelerator
+void accel_close(accel_t *accel);
+
+// Read 1024-bit operand from reg0
+int accel_read_vec0(accel_t *accel, uint32_t* data, uint32_t index);
+
+// Read 1024-bit operand from vec1
+int accel_read_vec1(accel_t *accel, uint32_t* data, uint32_t index);
+
+// Write 1024-bit operand to vec0
+int accel_write_vec0(accel_t *accel, uint32_t* data, uint32_t index);
+
+// Write 1024-bit operand to vec1
+int accel_write_vec1(accel_t *accel, uint32_t* data, uint32_t index);
+
+// Trigger the operation (opcode)
+int accel_trigger(accel_t *accel, uint32_t opcode);
+
+// Read 1024-bit result
+int accel_read_result(accel_t *accel, uint64_t* data, uint32_t index);
+
+#endif
diff --git a/package/accel_test/original-src/accel_test.c b/package/accel_test/original-src/accel_test.c
new file mode 100644
index 0000000000..2a13b05e96
--- /dev/null
+++ b/package/accel_test/original-src/accel_test.c
@@ -0,0 +1,156 @@
+#include "accel.h"
+#include <stdio.h>
+#include <stdint.h>
+#include <time.h>
+
+int sanity() {
+    accel_t accel;
+    printf("Opening accelerator...\n");
+    if (accel_open(&accel, NULL)) {
+        perror("accel_open");
+        return 1;
+    }
+    printf("Accelerator opened successfully!.\n");
+    printf("Testing vector write/read...\n");
+    // test write
+    uint32_t regs[2][32];
+    for (int i = 0; i < 32; ++i) {
+        accel_write_vec0(&accel, &(uint32_t){0xdead0000 + i}, i);
+        regs[0][i] = 0xdead0000 + i;
+    }
+    for (int i = 0; i < 32; ++i) {
+        accel_write_vec1(&accel, &(uint32_t){0xbeef0000 + i}, i);
+        regs[1][i] = 0xbeef0000 + i;
+    }
+    // test read
+    for (int i = 0; i < 32; ++i) {
+        uint32_t val0, val1;
+        accel_read_vec0(&accel, &val0, i);
+        accel_read_vec1(&accel, &val1, i);
+        if (val0 != regs[0][i] || val1 != regs[1][i]) {
+            printf("Read mismatch at index %d: vec0=%08x (expected %08x), vec1=%08x (expected %08x)\n",
+                   i, val0, regs[0][i], val1, regs[1][i]);
+            accel_close(&accel);
+            return 1;
+        }
+    }
+    printf("Vector write/read test passed.\n");
+    printf("Testing addition operation...\n");
+    accel_trigger(&accel, ACCEL_OP_ADD);        // opcode 1 = ADD
+    uint64_t result[32];
+    for (int i = 0; i < 32; ++i) {
+        accel_read_result(&accel, &result[i], i);
+        uint64_t expected = (uint64_t)(regs[0][i]) + (uint64_t)(regs[1][i]);
+        if (result[i] != expected) {
+            printf("Addition mismatch at index %d: result=%016lx (expected %016lx)\n",
+                   i, result[i], expected);
+            accel_close(&accel);
+            return 1;
+        }
+    }
+    printf("Addition operation test passed.\n");
+    // test multiplication operation
+    printf("Testing multiplication operation...\n");
+    accel_trigger(&accel, ACCEL_OP_MUL);        // opcode 6 = MUL
+    for (int i = 0; i < 32; ++i) {
+        accel_read_result(&accel, &result[i], i);
+        uint64_t expected = (uint64_t)(regs[0][i]) * (uint64_t)(regs[1][i]);
+        if (result[i] != expected) {
+            printf("Multiplication mismatch at index %d: result=%016lx (expected %016lx)\n",
+                   i, result[i], expected);
+            accel_close(&accel);
+            return 1;
+        }
+    }
+    printf("Multiplication operation test passed.\n");
+    accel_close(&accel);
+    return 0;
+}
+
+int accel_performance(accel_t* accel){
+    //write
+    for (int i = 0; i < 32; ++i) {
+        accel_write_vec0(accel, &(uint32_t){0xdead0000 + i}, i);
+    }
+    for (int i = 0; i < 32; ++i) {
+        accel_write_vec1(accel, &(uint32_t){0xbeef0000 + i}, i);
+    }
+    uint64_t val;
+    //Add
+    accel_trigger(accel, ACCEL_OP_ADD);
+    // for (int i = 0; i < 32; ++i) {
+    //     accel_read_result(accel, &val, i);
+    // }
+    //multiplication
+    accel_trigger(accel, ACCEL_OP_MUL);
+    // for (int i = 0; i < 32; ++i) {
+    //     accel_read_result(accel, &val, i);
+    // }
+    return 0;
+} 
+
+int base_performance(uint32_t regs[2][32], uint64_t res[32]) {
+    uint64_t val;
+    for (int i = 0; i < 32; ++i) {
+        regs[0][i] = 0xdead0000 + i;
+    }
+    for (int i = 0; i < 32; ++i) {
+        regs[1][i] = 0xbeef0000 + i;
+    }
+    //Add
+    for (int i = 0; i < 32; ++i) {
+        res[i] = (uint64_t)(regs[0][i]) + (uint64_t)(regs[1][i]);
+        val = res[i];
+    }
+    
+    //multiplication
+    for (int i = 0; i < 32; ++i) {
+        res[i] = (uint64_t)(regs[0][i]) * (uint64_t)(regs[1][i]);
+        val = res[i];
+    }
+    return 0;
+} 
+
+int main() {
+    if(sanity() != 0) {
+        printf("sanity fail\n");
+        return 1;
+    }
+    accel_t accel;
+    printf("Opening accelerator...\n");
+    if (accel_open(&accel, NULL)) {
+        perror("accel_open");
+        return 1;
+    }
+    printf("Accelerator opened successfully!.\n");
+    uint32_t regs[2][32]; 
+    uint64_t res[32];
+
+
+
+    uint32_t accel_avg = 0, base_avg = 0;
+    struct timespec start, end;
+    
+    for (size_t i = 1; i <= 100; i++)
+    {
+        clock_gettime(CLOCK_MONOTONIC, &start);
+        accel_performance(&accel);
+        clock_gettime(CLOCK_MONOTONIC, &end);
+        double elapsed = (end.tv_sec - start.tv_sec) * 1e9 + (end.tv_nsec - start.tv_nsec);
+        printf("Iteration %zu: Accelerator elapsed time: %.0f ns\n", i, elapsed);
+        accel_avg = ((accel_avg * (i - 1)) + elapsed) / i;
+
+        clock_gettime(CLOCK_MONOTONIC, &start);
+        base_performance(regs,res);
+        clock_gettime(CLOCK_MONOTONIC, &end);
+        elapsed = (end.tv_sec - start.tv_sec) * 1e9 + (end.tv_nsec - start.tv_nsec);
+        printf("Iteration %zu: base elapsed time: %.0f ns\n", i, elapsed);
+        base_avg = ((base_avg * (i - 1)) + elapsed) / i;
+    }
+    
+    printf("Accelerator average time: %u ns\n", accel_avg);
+    printf("Base average time: %u ns\n", base_avg);
+    accel_close(&accel);
+    return 0;
+   
+}
diff --git a/package/accel_test/src/Makefile b/package/accel_test/src/Makefile
new file mode 100644
index 0000000000..270bdccaee
--- /dev/null
+++ b/package/accel_test/src/Makefile
@@ -0,0 +1,13 @@
+# Use buildroot's cross-compiler (RISC-V)
+CC ?= $(TARGET_CC)
+CFLAGS ?= $(TARGET_CFLAGS)
+LDFLAGS ?= $(TARGET_LDFLAGS)
+
+all:
+	$(CC) $(CFLAGS) $(LDFLAGS) -o accel_test accel.c accel_test.c 
+
+install:
+	install -D -m 0755 accel_test $(DESTDIR)/usr/bin/accel_test
+
+clean:
+	rm -f accel_test
diff --git a/package/accel_test/src/accel.c b/package/accel_test/src/accel.c
new file mode 100644
index 0000000000..5bd57a0e0f
--- /dev/null
+++ b/package/accel_test/src/accel.c
@@ -0,0 +1,85 @@
+#include "accel.h"
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <string.h>
+#include <stdio.h>
+#include <errno.h>
+
+#define ACCEL_MAP_SIZE 0x1000  // total register space (needs to cover up to OPCODE_OFFSET + some space)
+
+// ---------------------------------------------------------------------------
+// Open / Close
+// ---------------------------------------------------------------------------
+
+int accel_open(accel_t *accel, const char *device) {
+    if (!device) device = DEVICE;
+    accel->fd = open(device, O_RDWR | O_SYNC);
+    if (accel->fd < 0) {
+        printf("Failed to open %s: %s\n", device, strerror(errno));
+        return -errno;
+    }
+
+    accel->regs = mmap(NULL, ACCEL_MAP_SIZE, PROT_READ | PROT_WRITE,
+                       MAP_SHARED, accel->fd, 0);
+    if (accel->regs == MAP_FAILED) {
+        printf("Failed to mmap %s: %s\n", device, strerror(errno));
+        int err = -errno;
+        close(accel->fd);
+        accel->fd = -1;
+        return err;
+    }
+
+    return 0;
+}
+
+void accel_close(accel_t *accel) {
+    if (accel->regs && accel->regs != MAP_FAILED) {
+        munmap((void *)accel->regs, ACCEL_MAP_SIZE);
+        accel->regs = NULL;
+    }
+    if (accel->fd >= 0)
+        close(accel->fd);
+    accel->fd = -1;
+}
+
+int accel_write_vec0(accel_t *accel, uint32_t *data, uint32_t index) {
+    volatile uint32_t *base = (volatile uint32_t *)((uint8_t *)accel->regs + REG0_OFFSET);
+    base[index] = *data;
+    return 0;
+}
+
+int accel_write_vec1(accel_t *accel, uint32_t *data, uint32_t index) {
+    volatile uint32_t *base = (volatile uint32_t *)((uint8_t *)accel->regs + REG1_OFFSET);
+    base[index] = *data;
+    return 0;
+}
+
+int accel_read_vec0(accel_t *accel, uint32_t *data, uint32_t index) {
+    volatile uint32_t *base = (volatile uint32_t *)((uint8_t *)accel->regs + REG0_OFFSET);
+    *data = base[index];
+    return 0;
+}
+
+int accel_read_vec1(accel_t *accel, uint32_t *data, uint32_t index) {
+    volatile uint32_t *base = (volatile uint32_t *)((uint8_t *)accel->regs + REG1_OFFSET);
+    *data = base[index];
+    return 0;
+}
+
+int accel_read_result(accel_t *accel, uint64_t *data, uint32_t index) {
+    volatile uint64_t *base = (volatile uint64_t *)((uint8_t *)accel->regs + REG_RESULT_OFFSET);
+    *data = base[index];
+    return 0;
+}
+
+// ---------------------------------------------------------------------------
+// IOCTL trigger (still system call, should be fine)
+// ---------------------------------------------------------------------------
+
+int accel_trigger(accel_t *accel, uint32_t opcode) {
+    volatile uint64_t *base = (volatile uint64_t *)((uint8_t *)accel->regs + OPCODE_OFFSET);
+    base[0] = opcode;
+    return 0;
+}
diff --git a/package/accel_test/src/accel.h b/package/accel_test/src/accel.h
new file mode 100644
index 0000000000..ec0f7496af
--- /dev/null
+++ b/package/accel_test/src/accel.h
@@ -0,0 +1,54 @@
+#ifndef ACCEL_H
+#define ACCEL_H
+
+#include <stdint.h>
+#include <sys/types.h>
+
+#define DEVICE "/dev/accel"
+#define ACCEL_IOC_MAGIC 'x'
+#define ACCEL_IOC_OPCODE _IOW(ACCEL_IOC_MAGIC, 1, uint32_t)
+#define REG0_OFFSET       0x00
+#define REG1_OFFSET       0x80
+#define REG_RESULT_OFFSET 0x100
+#define OPCODE_OFFSET     0x180
+
+typedef struct {
+    int fd;
+    void *regs;
+} accel_t;
+
+enum accel_opcodes {
+    ACCEL_OP_ADD = 1,
+    ACCEL_OP_SUB = 2,
+    ACCEL_OP_AND = 3,
+    ACCEL_OP_OR = 4,
+    ACCEL_OP_XOR = 5,
+    ACCEL_OP_MUL = 6,
+    ACCEL_OP_MOV = 7
+};
+
+// Initialize the accelerator
+int accel_open(accel_t *accel, const char *device);
+
+// Close accelerator
+void accel_close(accel_t *accel);
+
+// Read 1024-bit operand from reg0
+int accel_read_vec0(accel_t *accel, uint32_t* data, uint32_t index);
+
+// Read 1024-bit operand from vec1
+int accel_read_vec1(accel_t *accel, uint32_t* data, uint32_t index);
+
+// Write 1024-bit operand to vec0
+int accel_write_vec0(accel_t *accel, uint32_t* data, uint32_t index);
+
+// Write 1024-bit operand to vec1
+int accel_write_vec1(accel_t *accel, uint32_t* data, uint32_t index);
+
+// Trigger the operation (opcode)
+int accel_trigger(accel_t *accel, uint32_t opcode);
+
+// Read 1024-bit result
+int accel_read_result(accel_t *accel, uint64_t* data, uint32_t index);
+
+#endif
diff --git a/package/accel_test/src/accel_test.c b/package/accel_test/src/accel_test.c
new file mode 100644
index 0000000000..c2333391ee
--- /dev/null
+++ b/package/accel_test/src/accel_test.c
@@ -0,0 +1,148 @@
+#include "accel.h"
+#include <stdio.h>
+#include <stdint.h>
+#include <time.h>
+
+int sanity() {
+    accel_t accel;
+    printf("Opening accelerator...\n");
+    if (accel_open(&accel, NULL)) {
+        perror("accel_open");
+        return 1;
+    }
+    printf("Accelerator opened successfully!.\n");
+    printf("Testing vector write/read...\n");
+    // test write
+    uint32_t regs[2][32];
+    for (int i = 0; i < 32; ++i) {
+        accel_write_vec0(&accel, &(uint32_t){0xdead0000 + i}, i);
+        regs[0][i] = 0xdead0000 + i;
+    }
+    for (int i = 0; i < 32; ++i) {
+        accel_write_vec1(&accel, &(uint32_t){0xbeef0000 + i}, i);
+        regs[1][i] = 0xbeef0000 + i;
+    }
+    printf("Vector write completed.\n");
+    // test read
+    for (int i = 0; i < 32; ++i) {
+        uint32_t val0, val1;
+        accel_read_vec0(&accel, &val0, i);
+        accel_read_vec1(&accel, &val1, i);
+        if (val0 != regs[0][i] || val1 != regs[1][i]) {
+            printf("Read mismatch at index %d: vec0=%08x (expected %08x), vec1=%08x (expected %08x)\n",
+                   i, val0, regs[0][i], val1, regs[1][i]);
+            accel_close(&accel);
+            return 1;
+        }
+    }
+    printf("Vector write/read test passed.\n");
+    printf("Testing addition operation...\n");
+    accel_trigger(&accel, ACCEL_OP_ADD);        // opcode 1 = ADD
+    uint64_t result[32];
+    for (int i = 0; i < 32; ++i) {
+        accel_read_result(&accel, &result[i], i);
+        uint64_t expected = (uint64_t)(regs[0][i]) + (uint64_t)(regs[1][i]);
+        if (result[i] != expected) {
+            printf("Addition mismatch at index %d: result=%016lx (expected %016lx)\n",
+                   i, result[i], expected);
+            accel_close(&accel);
+            return 1;
+        }
+    }
+    printf("Addition operation test passed.\n");
+    // test multiplication operation
+    printf("Testing multiplication operation...\n");
+    accel_trigger(&accel, ACCEL_OP_MUL);        // opcode 6 = MUL
+    for (int i = 0; i < 32; ++i) {
+        accel_read_result(&accel, &result[i], i);
+        uint64_t expected = (uint64_t)(regs[0][i]) * (uint64_t)(regs[1][i]);
+        if (result[i] != expected) {
+            printf("Multiplication mismatch at index %d: result=%016lx (expected %016lx)\n",
+                   i, result[i], expected);
+            accel_close(&accel);
+            return 1;
+        }
+    }
+    printf("Multiplication operation test passed.\n");
+    accel_close(&accel);
+    return 0;
+}
+
+int accel_performance(accel_t* accel){
+    //write
+    for (int i = 0; i < 32; ++i) {
+        accel_write_vec0(accel, &(uint32_t){0xdead0000 + i}, i);
+    }
+    for (int i = 0; i < 32; ++i) {
+        accel_write_vec1(accel, &(uint32_t){0xbeef0000 + i}, i);
+    }
+    uint64_t val;
+    //Add
+    accel_trigger(accel, ACCEL_OP_ADD);
+    //multiplication
+    accel_trigger(accel, ACCEL_OP_MUL);
+    return 0;
+} 
+
+int base_performance(uint32_t regs[2][32], uint64_t res[32]) {
+    uint64_t val;
+    for (int i = 0; i < 32; ++i) {
+        regs[0][i] = 0xdead0000 + i;
+    }
+    for (int i = 0; i < 32; ++i) {
+        regs[1][i] = 0xbeef0000 + i;
+    }
+    //Add
+    for (int i = 0; i < 32; ++i) {
+        res[i] = (uint64_t)(regs[0][i]) + (uint64_t)(regs[1][i]);
+    }
+    
+    //multiplication
+    for (int i = 0; i < 32; ++i) {
+        res[i] = (uint64_t)(regs[0][i]) * (uint64_t)(regs[1][i]);
+    }
+    return 0;
+}
+
+
+int main() {
+    if(sanity() != 0) {
+        printf("sanity fail\n");
+        return 1;
+    }
+    accel_t accel;
+    printf("Opening accelerator...\n");
+    if (accel_open(&accel, NULL)) {
+        perror("accel_open");
+        return 1;
+    }
+    printf("Accelerator opened successfully!.\n");
+    uint32_t regs[2][32]; 
+    uint64_t res[32];
+
+
+
+    uint32_t accel_avg = 0, base_avg = 0;
+    struct timespec start, end;
+    // performance evaluation
+    for (size_t i = 1; i <= 100; i++)
+    {
+        clock_gettime(CLOCK_MONOTONIC, &start);
+        accel_performance(&accel);
+        clock_gettime(CLOCK_MONOTONIC, &end);
+        double elapsed = (end.tv_sec - start.tv_sec) * 1e9 + (end.tv_nsec - start.tv_nsec);
+        accel_avg = ((accel_avg * (i - 1)) + elapsed) / i;
+        asm volatile ("fence rw, rw" ::: "memory");
+        clock_gettime(CLOCK_MONOTONIC, &start);
+        base_performance(regs,res);
+        clock_gettime(CLOCK_MONOTONIC, &end);
+        elapsed = (end.tv_sec - start.tv_sec) * 1e9 + (end.tv_nsec - start.tv_nsec);
+        base_avg = ((base_avg * (i - 1)) + elapsed) / i;
+    }
+    
+    printf("Accelerator average time: %u ns\n", accel_avg);
+    printf("Base average time: %u ns\n", base_avg);
+    accel_close(&accel);
+    return 0;
+   
+}
diff --git a/package/accel_test/src/accel_test_working.c b/package/accel_test/src/accel_test_working.c
new file mode 100644
index 0000000000..5e9f2c2c9b
--- /dev/null
+++ b/package/accel_test/src/accel_test_working.c
@@ -0,0 +1,157 @@
+#include "accel.h"
+#include <stdio.h>
+#include <stdint.h>
+#include <time.h>
+
+int sanity() {
+    accel_t accel;
+    printf("Opening accelerator...\n");
+    if (accel_open(&accel, NULL)) {
+        perror("accel_open");
+        return 1;
+    }
+    printf("Accelerator opened successfully!.\n");
+    printf("Testing vector write/read...\n");
+    // test write
+    uint32_t regs[2][32];
+    for (int i = 0; i < 32; ++i) {
+        accel_write_vec0(&accel, &(uint32_t){0xdead0000 + i}, i);
+        regs[0][i] = 0xdead0000 + i;
+    }
+    for (int i = 0; i < 32; ++i) {
+        accel_write_vec1(&accel, &(uint32_t){0xbeef0000 + i}, i);
+        regs[1][i] = 0xbeef0000 + i;
+    }
+    printf("Vector write completed.\n");
+    // test read
+    for (int i = 0; i < 32; ++i) {
+        uint32_t val0, val1;
+        accel_read_vec0(&accel, &val0, i);
+        accel_read_vec1(&accel, &val1, i);
+        if (val0 != regs[0][i] || val1 != regs[1][i]) {
+            printf("Read mismatch at index %d: vec0=%08x (expected %08x), vec1=%08x (expected %08x)\n",
+                   i, val0, regs[0][i], val1, regs[1][i]);
+            accel_close(&accel);
+            return 1;
+        }
+    }
+    printf("Vector write/read test passed.\n");
+    printf("Testing addition operation...\n");
+    accel_trigger(&accel, ACCEL_OP_ADD);        // opcode 1 = ADD
+    uint64_t result[32];
+    for (int i = 0; i < 32; ++i) {
+        accel_read_result(&accel, &result[i], i);
+        uint64_t expected = (uint64_t)(regs[0][i]) + (uint64_t)(regs[1][i]);
+        if (result[i] != expected) {
+            printf("Addition mismatch at index %d: result=%016lx (expected %016lx)\n",
+                   i, result[i], expected);
+            accel_close(&accel);
+            return 1;
+        }
+    }
+    printf("Addition operation test passed.\n");
+    // test multiplication operation
+    printf("Testing multiplication operation...\n");
+    accel_trigger(&accel, ACCEL_OP_MUL);        // opcode 6 = MUL
+    for (int i = 0; i < 32; ++i) {
+        accel_read_result(&accel, &result[i], i);
+        uint64_t expected = (uint64_t)(regs[0][i]) * (uint64_t)(regs[1][i]);
+        if (result[i] != expected) {
+            printf("Multiplication mismatch at index %d: result=%016lx (expected %016lx)\n",
+                   i, result[i], expected);
+            accel_close(&accel);
+            return 1;
+        }
+    }
+    printf("Multiplication operation test passed.\n");
+    accel_close(&accel);
+    return 0;
+}
+
+int accel_performance(accel_t* accel){
+    //write
+    for (int i = 0; i < 32; ++i) {
+        accel_write_vec0(accel, &(uint32_t){0xdead0000 + i}, i);
+    }
+    for (int i = 0; i < 32; ++i) {
+        accel_write_vec1(accel, &(uint32_t){0xbeef0000 + i}, i);
+    }
+    uint64_t val;
+    //Add
+    accel_trigger(accel, ACCEL_OP_ADD);
+    // for (int i = 0; i < 32; ++i) {
+    //     accel_read_result(accel, &val, i);
+    // }
+    //multiplication
+    accel_trigger(accel, ACCEL_OP_MUL);
+    // for (int i = 0; i < 32; ++i) {
+    //     accel_read_result(accel, &val, i);
+    // }
+    return 0;
+} 
+
+int base_performance(uint32_t regs[2][32], uint64_t res[32]) {
+    uint64_t val;
+    for (int i = 0; i < 32; ++i) {
+        regs[0][i] = 0xdead0000 + i;
+    }
+    for (int i = 0; i < 32; ++i) {
+        regs[1][i] = 0xbeef0000 + i;
+    }
+    //Add
+    for (int i = 0; i < 32; ++i) {
+        res[i] = (uint64_t)(regs[0][i]) + (uint64_t)(regs[1][i]);
+        val = res[i];
+    }
+    
+    //multiplication
+    for (int i = 0; i < 32; ++i) {
+        res[i] = (uint64_t)(regs[0][i]) * (uint64_t)(regs[1][i]);
+        val = res[i];
+    }
+    return 0;
+} 
+
+int main() {
+    if(sanity() != 0) {
+        printf("sanity fail\n");
+        return 1;
+    }
+    accel_t accel;
+    printf("Opening accelerator...\n");
+    if (accel_open(&accel, NULL)) {
+        perror("accel_open");
+        return 1;
+    }
+    printf("Accelerator opened successfully!.\n");
+    uint32_t regs[2][32]; 
+    uint64_t res[32];
+
+
+
+    uint32_t accel_avg = 0, base_avg = 0;
+    struct timespec start, end;
+    
+    for (size_t i = 1; i <= 100; i++)
+    {
+        clock_gettime(CLOCK_MONOTONIC, &start);
+        accel_performance(&accel);
+        clock_gettime(CLOCK_MONOTONIC, &end);
+        double elapsed = (end.tv_sec - start.tv_sec) * 1e9 + (end.tv_nsec - start.tv_nsec);
+        printf("Iteration %zu: Accelerator elapsed time: %.0f ns\n", i, elapsed);
+        accel_avg = ((accel_avg * (i - 1)) + elapsed) / i;
+
+        clock_gettime(CLOCK_MONOTONIC, &start);
+        base_performance(regs,res);
+        clock_gettime(CLOCK_MONOTONIC, &end);
+        elapsed = (end.tv_sec - start.tv_sec) * 1e9 + (end.tv_nsec - start.tv_nsec);
+        printf("Iteration %zu: base elapsed time: %.0f ns\n", i, elapsed);
+        base_avg = ((base_avg * (i - 1)) + elapsed) / i;
+    }
+    
+    printf("Accelerator average time: %u ns\n", accel_avg);
+    printf("Base average time: %u ns\n", base_avg);
+    accel_close(&accel);
+    return 0;
+   
+}
